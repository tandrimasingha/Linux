Comment
#include <stdio.h>
#include <string.h>

int main() {
    char line[100];
    int isComment = 0;
    
    printf("Enter a line: ");
    fgets(line, sizeof(line), stdin);
    
    if (line[0] == '/' && line[1] == '/') { // single line comment
        isComment = 1;
    } else if (line[0] == '/' && line[1] == '*') { // multiline comment start
        isComment = 1;
    } else if (line[strlen(line)-2] == '*' && line[strlen(line)-1] == '/') { // multiline comment end
        isComment = 1;
    }
    
    if (isComment) {
        printf("The line is a comment.\n");
    } else {
        printf("The line is not a comment.\n");
    }
    
    return 0;
}

Automata

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

void main()

{

char s[20],c;

int state=0,i=0;



printf("\n Enter a string:");

gets(s);

while(s[i]!='\0')

{

switch(state)

{

case 0: c=s[i++];

if(c=='a')

state=1;

else if(c=='b')

state=2;

else

state=6;

break;

case 1: c=s[i++];

if(c=='a')

state=3;

else if(c=='b')

state=4;

else

state=6;

break;

case 2: c=s[i++];

if(c=='a')

state=6;

else if(c=='b')

state=2;

else

state=6;

break;

case 3: c=s[i++];

if(c=='a')

state=3;

else if(c=='b')

state=2;

else

state=6;

break;

case 4: c=s[i++];

if(c=='a')

state=6;




else if(c=='b')

state=5;

else

state=6;

break;

case 5: c=s[i++];

if(c=='a')

state=6;

else if(c=='b')

state=2;

else

state=6;

break;

case 6: printf("\n %s is not recognised.",s);

exit(0);

}

}

if(state==1)

printf("\n %s is accepted under rule 'a'",s);

else if((state==2)||(state==4))

printf("\n %s is accepted under rule 'a*b+'",s);

else if(state==5)

printf("\n %s is accepted under rule 'abb'",s);

getch();

}


Write in a file
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main()
{
    FILE *fp;
    char s[100];
    fp=fopen("File123","w");
    printf("Give input \n");
    while(strlen(fgets(s,100,stdin))>1)
    {
        fputs(s,fp);
        fputs("\n",fp);
    }
    close(fp);
    return 0;
}



Read in a file
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main()
{
    FILE *fp;
    char s[100];
    fp=fopen("File123","r");
    while((fgets(s,100,fp))!=NULL)
    {
        printf("%s",s);
    }
    fputs(s,fp);
    fclose(fp);
    return 0;
    
}


count no of tokens
#include <stdio.h>
#include <ctype.h>
#include <string.h>

int is_operator(char ch) {
    // Check if character is an operator
    char operators[] = "+-*/%=<>&|^!";
    int i;
    for(i = 0; i < strlen(operators); ++i) {
        if(ch == operators[i]) {
            return 1;
        }
    }
    return 0;
}

int is_whitespace(char ch) {
    // Check if character is whitespace
    if(ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
        return 1;
    }
    return 0;
}

int main() {
    FILE *fp;
    char ch, prev_ch = '\0';
    int count = 0;

    fp = fopen("program.c", "r");

    if(fp == NULL) {
        printf("Error: Unable to open file.\n");
        return 0;
    }

    while((ch = fgetc(fp)) != EOF) {
        if(is_operator(ch) || is_whitespace(ch)) {
            // Count token if previous character was not whitespace or operator
            if(!is_whitespace(prev_ch) && !is_operator(prev_ch)) {
                count++;
            }
        }
        prev_ch = ch;
    }

    // Count token if last character was not whitespace or operator
    if(!is_whitespace(prev_ch) && !is_operator(prev_ch)) {
        count++;
    }

    printf("Total number of tokens: %d\n", count);

    fclose(fp);
    return 0;
}



shift reducer parser
#include<stdio.h>
#include<stdlib.h>
#include<string.h>


int z = 0, i = 0, j = 0, c = 0;


char a[16], ac[20], stk[15], act[10];


void check()
{
	
	strcpy(ac,"REDUCE TO E -> ");
	
	
	for(z = 0; z < c; z++)
	{
		//checking for producing rule E->4
		if(stk[z] == '4')
		{
			printf("%s4", ac);
			stk[z] = 'E';
			stk[z + 1] = '\0';
			
			
			printf("\n$%s\t%s$\t", stk, a);
		}
	}
		
	for(z = 0; z < c - 2; z++)
	{
	
		if(stk[z] == '2' && stk[z + 1] == 'E' &&
								stk[z + 2] == '2')
		{
			printf("%s2E2", ac);
			stk[z] = 'E';
			stk[z + 1] = '\0';
			stk[z + 2] = '\0';
			printf("\n$%s\t%s$\t", stk, a);
			i = i - 2;
		}
		
	}
		
	for(z=0; z<c-2; z++)
	{
		
		if(stk[z] == '3' && stk[z + 1] == 'E' &&
								stk[z + 2] == '3')
		{
			printf("%s3E3", ac);
			stk[z]='E';
			stk[z + 1]='\0';
			stk[z + 1]='\0';
			printf("\n$%s\t%s$\t", stk, a);
			i = i - 2;
		}
	}
	return ; //return to main
}


int main()
{
	printf("GRAMMAR is -\nE->2E2 \nE->3E3 \nE->4\n");
	
	
	strcpy(a,"32423");
	
	
	c=strlen(a);
	
	
	strcpy(act,"SHIFT");
	

	printf("\nstack \t input \t action");
	
	
	printf("\n$\t%s$\t", a);
	
	
	for(i = 0; j < c; i++, j++)
	{
		
		printf("%s", act);
		
			stk[i] = a[j];	
		stk[i + 1] = '\0';
		
		
		a[j]=' ';
		
		
		printf("\n$%s\t%s$\t", stk, a);
		
		check();
	}
	
	
	check();
	

	if(stk[0] == 'E' && stk[1] == '\0')
		printf("Accept\n");
	else //else reject
		printf("Reject\n");
}

Operator Precedence Parsing Program in C 
#include<stdio.h>
#include<string.h>

char *input;
int i=0;
char lasthandle[6],stack[50],handles[][5]={")E(","E*E","E+E","i","E^E"};
//(E) becomes )E( when pushed to stack

int top=0,l;
char prec[9][9]={

                            /*input*/

            /*stack    +    -   *   /   ^   i   (   )   $  */

            /*  + */  '>', '>','<','<','<','<','<','>','>',

            /*  - */  '>', '>','<','<','<','<','<','>','>',

            /*  * */  '>', '>','>','>','<','<','<','>','>',

            /*  / */  '>', '>','>','>','<','<','<','>','>',

            /*  ^ */  '>', '>','>','>','<','<','<','>','>',

            /*  i */  '>', '>','>','>','>','e','e','>','>',

            /*  ( */  '<', '<','<','<','<','<','<','>','e',

            /*  ) */  '>', '>','>','>','>','e','e','>','>',

            /*  $ */  '<', '<','<','<','<','<','<','<','>',

                };

int getindex(char c)
{
switch(c)
    {
    case '+':return 0;
    case '-':return 1;
    case '*':return 2;
    case '/':return 3;
    case '^':return 4;
    case 'i':return 5;
    case '(':return 6;
    case ')':return 7;
    case '$':return 8;
    }
}


int shift()
{
stack[++top]=*(input+i++);
stack[top+1]='\0';
}


int reduce()
{
int i,len,found,t;
for(i=0;i<5;i++)//selecting handles
    {
    len=strlen(handles[i]);
    if(stack[top]==handles[i][0]&&top+1>=len)
        {
        found=1;
        for(t=0;t<len;t++)
            {
            if(stack[top-t]!=handles[i][t])
                {
                found=0;
                break;
                }
            }
        if(found==1)
            {
            stack[top-t+1]='E';
            top=top-t+1;
            strcpy(lasthandle,handles[i]);
            stack[top+1]='\0';
            return 1;//successful reduction
            }
        }
   }
return 0;
}



void dispstack()
{
int j;
for(j=0;j<=top;j++)
    printf("%c",stack[j]);
}



void dispinput()
{
int j;
for(j=i;j<l;j++)
    printf("%c",*(input+j));
}



void main()
{
int j;

input=(char*)malloc(50*sizeof(char));
printf("\nEnter the string\n");
scanf("%s",input);
input=strcat(input,"$");
l=strlen(input);
strcpy(stack,"$");
printf("\nSTACK\tINPUT\tACTION");
while(i<=l)
	{
	shift();
	printf("\n");
	dispstack();
	printf("\t");
	dispinput();
	printf("\tShift");
	if(prec[getindex(stack[top])][getindex(input[i])]=='>')
		{
		while(reduce())
			{
			printf("\n");
			dispstack();
			printf("\t");
			dispinput();
			printf("\tReduced: E->%s",lasthandle);
			}
		}
	}

if(strcmp(stack,"$E$")==0)
    printf("\nAccepted;");
else
    printf("\nNot Accepted;");
}